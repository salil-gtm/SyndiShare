{
  "manifest": {
    "name": "aes-js",
    "version": "0.2.4",
    "bugs": {
      "url": "http://github.com/ricmoo/aes-js/issues",
      "email": "github@ricmoo.com"
    },
    "description": "A pure JavaScript implementation of the AES block cipher and all common modes of operation.",
    "devDependencies": {
      "nodeunit": "0.9.1"
    },
    "main": "index.js",
    "scripts": {
      "test": "node test/test-aes.js && node test/test-counter.js && node test/test-buffer.js"
    },
    "repository": {
      "type": "git",
      "url": "git://github.com/ricmoo/aes-js.git"
    },
    "keywords": [
      "aes",
      "aes-ctr",
      "aes-ofb",
      "aes-ecb",
      "aes-cbc",
      "aes-cfb",
      "encrypt",
      "decrypt",
      "block",
      "cipher"
    ],
    "author": {
      "name": "Richard Moore",
      "email": "me@ricmoo.com"
    },
    "license": "MIT",
    "_registry": "npm",
    "_loc": "/home/salil007/.cache/yarn/v2/npm-aes-js-0.2.4-94b881ab717286d015fa219e08fb66709dda5a3d/package.json",
    "readmeFilename": "README.md",
    "readme": "AES-JS\n======\n\n[![npm version](https://badge.fury.io/js/aes-js.svg)](https://badge.fury.io/js/aes-js)\n\nA pure JavaScript implementation of the AES block cipher algorithm and all common modes of operation (CBC, CFB, CTR, ECB and OFB).\n\nFeatures\n--------\n\n- Pure JavaScript (with no dependencies)\n- Supports all key sizes (128-bit, 192-bit and 256-bit)\n- Supports all common modes of operation (CBC, CFB, CTR, ECB and OFB)\n- Works in either node.js or web browsers\n\n\nAPI\n===\n\n#### Node.js\n\nTo install `aes-js` in your node.js project:\n\n```\nnpm install aes-js\n```\n\nAnd to access it from within node, simply add:\n\n```javascript\nvar aesjs = require('aes-js');\n```\n\n#### Web Browser\n\nTo use `aes-js` in a web page, add the following:\n\n```html\n<script type=\"text/javascript\" src=\"https://raw.githubusercontent.com/ricmoo/aes-js/master/index.js\"></script>\n```\n\nKeys\n----\n\nAll keys must be 128 bits (16 bytes), 192 bits (24 bytes) or 256 bits (32 bytes) long. The API's work on either arrays or `Buffer` objects.\n\n```javascript\n// 128-bit, 192-bit and 256-bit keys\nvar key_128 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\nvar key_192 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23];\nvar key_256 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\n               29, 30, 31];\n\n// or, similarly, with buffers (node.js only):\nvar key_128 = new Buffer([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]);\nvar key_192 = new Buffer([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23]);\nvar key_256 = new Buffer([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n               16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28,\n               29, 30, 31]);\n\n```\n\n\nTo generate keys from simple-to-remember passwords, consider using a password-based key-derivation function such as [scrypt](https://www.npmjs.com/search?q=scrypt) or [bcrypt](https://www.npmjs.com/search?q=bcrypt).\n\n\nCommon Modes of Operation\n-------------------------\n\nThere are several modes of operations, each with various pros and cons. In general though, the **CBC** and **CTR** modes are recommended. The **ECB is NOT recommended.**, and is included primarily for completeness.\n\n### CTR - Counter (recommended)\n\n```javascript\nvar key = aesjs.util.convertStringToBytes(\"Example128BitKey\");\n\n// Convert text to bytes\nvar text = 'Text may be any length you wish, no padding is required.';\nvar textBytes = aesjs.util.convertStringToBytes(text);\n\n// The counter is optional, and if omitted will begin at 0\nvar aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\nvar encryptedBytes = aesCtr.encrypt(textBytes);\n\n// The counter mode of operation maintains internal state, so to\n// decrypt a new instance must be instantiated.\nvar aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\nvar decryptedBytes = aesCtr.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.util.convertBytesToString(decryptedBytes);\nconsole.log(decryptedText);\n// \"Text may be any length you wish, no padding is required.\"\n```\n\n\n### CBC - Cipher-Block Chaining (recommended)\n\n```javascript\nvar key = aesjs.util.convertStringToBytes(\"Example128BitKey\");\n\n// The initialization vector, which must be 16 bytes\nvar iv = aesjs.util.convertStringToBytes(\"IVMustBe16Bytes.\");\n\n// Convert text to bytes\nvar text = 'TextMustBe16Byte';\nvar textBytes = aesjs.util.convertStringToBytes(text);\n\nvar aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);\nvar encryptedBytes = aesCbc.encrypt(textBytes);\n\n// The cipher-block chaining mode of operation maintains internal\n// state, so to decrypt a new instance must be instantiated.\nvar aesCbc = new aesjs.ModeOfOperation.cbc(key, iv);\nvar decryptedBytes = aesCbc.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.util.convertBytesToString(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBe16Byte\"\n```\n\n\n### CFB - Cipher Feedback \n\n```javascript\nvar key = aesjs.util.convertStringToBytes(\"Example128BitKey\");\n\n// The initialization vector, which must be 16 bytes\nvar iv = aesjs.util.convertStringToBytes(\"IVMustBe16Bytes.\");\n\n// Convert text to bytes\nvar text = 'TextMustBeAMultipleOfSegmentSize';\nvar textBytes = aesjs.util.convertStringToBytes(text);\n\n// The segment size is optional, and defaults to 1\nvar aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, 8);\nvar encryptedBytes = aesCfb.encrypt(textBytes);\n\n// The cipher feedback mode of operation maintains internal state,\n// so to decrypt a new instance must be instantiated.\nvar aesCfb = new aesjs.ModeOfOperation.cfb(key, iv, 8);\nvar decryptedBytes = aesCfb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.util.convertBytesToString(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBeAMultipleOfSegmentSize\"\n```\n\n\n### OFB - Output Feedback\n\n```javascript\nvar key = aesjs.util.convertStringToBytes(\"Example128BitKey\");\n\n// The initialization vector, which must be 16 bytes\nvar iv = aesjs.util.convertStringToBytes(\"IVMustBe16Bytes.\");\n\n// Convert text to bytes\nvar text = 'Text may be any length you wish, no padding is required.';\nvar textBytes = aesjs.util.convertStringToBytes(text);\n\nvar aesOfb = new aesjs.ModeOfOperation.ofb(key, iv);\nvar encryptedBytes = aesOfb.encrypt(textBytes);\n\n// The output feedback mode of operation maintains internal state,\n// so to decrypt a new instance must be instantiated.\nvar aesOfb = new aesjs.ModeOfOperation.ofb(key, iv);\nvar decryptedBytes = aesOfb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.util.convertBytesToString(decryptedBytes);\nconsole.log(decryptedText);\n// \"Text may be any length you wish, no padding is required.\"\n```\n\n\n### ECB - Electronic Codebook (NOT recommended)\n\nThis mode is **not** recommended. Since, for a given key, the same plaintext block in produces the same ciphertext block out, this mode of operation can leak data, such as patterns. For more details and examples, see the Wikipedia article, [Electronic Codebook](http://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_Codebook_.28ECB.29).\n\n```javascript\nvar key = aesjs.util.convertStringToBytes(\"Example128BitKey\");\n\n// Convert text to bytes\nvar text = 'TextMustBe16Byte';\nvar textBytes = aesjs.util.convertStringToBytes(text);\n\nvar aesEcb = new aesjs.ModeOfOperation.ecb(key);\nvar encryptedBytes = aesEcb.encrypt(textBytes);\n\n// Since electronic codebook does not store state, we can\n// reuse the same instance.\n//var aesEcb = new aesjs.ModeOfOperation.ecb(key);\nvar decryptedBytes = aesEcb.decrypt(encryptedBytes);\n\n// Convert our bytes back into text\nvar decryptedText = aesjs.util.convertBytesToString(decryptedBytes);\nconsole.log(decryptedText);\n// \"TextMustBe16Byte\"\n```\n\n\n\nBlock Cipher\n------------\n\nYou should usually use one of the above common modes of operation. Using the block cipher algorithm directly is also possible using **ECB** as that mode of operation is merely a thin wrapper.\n\nBut this might be useful to experiment with custom modes of operation or play with block cipher algorithms.\n\n```javascript\n\n// the AES block cipher algorithm works on 16 byte bloca ks, no more, no less\nvar text = \"ABlockIs16Bytes!\";\nvar textAsBytes = aesjs.util.convertStringToBytes(text)\nconsole.log(textAsBytes);\n// [65, 66, 108, 111, 99, 107, 73, 115, 49, 54, 66, 121, 116, 101, 115, 33]\n\n\n// create an instance of the block cipher algorithm\nvar key = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9, 3];\nvar aes = new aesjs.AES(key);\n\n\n// encrypt...\nvar encryptedBytes = aes.encrypt(textAsBytes);\nconsole.log(encryptedBytes);\n// [136, 15, 199, 174, 118, 133, 233, 177, 143, 47, 42, 211, 96, 55, 107, 109] \n\n\n// decrypt...\nvar decryptedBytes = aes.decrypt(encryptedBytes);\nconsole.log(decryptedBytes);\n// [65, 66, 108, 111, 99, 107, 73, 115, 49, 54, 66, 121, 116, 101, 115, 33]\n\n\n// decode the bytes back into our original text\nvar decryptedText = aesjs.util.convertBytesToString(decryptedBytes);\nconsole.log(decryptedText);\n// \"ABlockIs16Bytes!\"\n```\n\n\nNotes\n=====\n\nWhat is a Key\n-------------\n\nThis seems to be a point of confusion for many people new to using encryption. You can think of the key as the *\"password\"*. However, these algorithms require the *\"password\"* to be a specific length.\n\nWith AES, there are three possible key lengths, 128-bit (16 bytes), 192-bit (24 bytes) or 256-bit (32 bytes). When you create an AES object, the key size is automatically detected, so it is important to pass in a key of the correct length.\n\nOften, you wish to provide a password of arbitrary length, for example, something easy to remember or write down. In these cases, you must come up with a way to transform the password into a key of a specific length. A **Password-Based Key Derivation Function** (PBKDF) is an algorithm designed for this exact purpose.\n\nHere is an example, using the popular (possibly obsolete?) pbkdf2:\n\n```javascript\nvar pbkdf2 = require('pbkdf2');\n\nvar key_128 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 128 / 8, 'sha512');\nvar key_192 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 192 / 8, 'sha512');\nvar key_256 = pbkdf2.pbkdf2Sync('password', 'salt', 1, 256 / 8, 'sha512');\n```\n\nAnother possibility, is to use a hashing function, such as SHA256 to hash the password, but this method is vulnerable to [Rainbow Attacks](http://en.wikipedia.org/wiki/Rainbow_table), unless you use a [salt](http://en.wikipedia.org/wiki/Salt_(cryptography)).\n\nPerformance\n-----------\n\nTodo...\n\nTests\n-----\n\nA test suite has been generated (`test/test-vectors.json`) from a known correct implementation, [pycrypto](https://www.dlitz.net/software/pycrypto/). To generate new test vectors, run `python generate-tests.py`.\n\nTo run the node.js test suite:\n\n```\nnpm test\n```\n\nTo run the web browser tests, open the `test/test.html` file in your browser.\n\nFAQ\n---\n\n#### How do I get a question I have added?\n\nE-mail me at aes-js@ricmoo.com with any questions, suggestions, comments, et cetera.\n\n\nDonations\n---------\n\nObviously, it's all licensed under the MIT license, so use it as you wish; but if you'd like to buy me a coffee, I won't complain. =)\n\n- Bitcoin - `1K1Ax9t6uJmjE4X5xcoVuyVTsiLrYRqe2P`\n- Dogecoin - `DFhgqVuaboxFnGQssyX84ZuV5r6aBRz8QJ`\n- Testnet3 - `n1F2Eb6cknqqknUPp7m9oBNMgXFuaDowvF`\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) 2015 Richard Moore\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/aes-js/-/aes-js-0.2.4.tgz#94b881ab717286d015fa219e08fb66709dda5a3d",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/aes-js/-/aes-js-0.2.4.tgz",
    "hash": "94b881ab717286d015fa219e08fb66709dda5a3d",
    "registry": "npm"
  },
  "registry": "npm",
  "hash": "94b881ab717286d015fa219e08fb66709dda5a3d"
}